import t from"vue";function e(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var n={};function r(t){var r=new t,i=Object.getOwnPropertyNames(r);void 0===r.moduleName&&console.error("You need to define the 'moduleName' class variable inside '".concat(r.constructor.name,"'! Otherwise it won't be added to the Vuex Store!")),o(r),n[a(r)].moduleName=r.moduleName,i.splice(i.indexOf("moduleName"),1);n[a(r)].state=function(){return function(t,e){for(var n={},r=0;r<Object.keys(e).length;r++){var o=e[Object.keys(e)[r]];n[o]=t[o]}return n}(r,i)};var s=Object.getPrototypeOf(r),c=Object.getOwnPropertyNames(s),u=[],f=[],l=!0,g=!1,v=void 0;try{for(var m,d=function(){var t=m.value,n=Object.getOwnPropertyDescriptor(s,t);n&&n.get?u[t]=function(t,r,o,a){for(var i={$store:{state:t,getters:r,rootState:o,rootGetters:a}},s=Object.keys(t),c=0;c<s.length;c++){var u=s[c];Object.assign(i,e({},u,t[u]))}return n.get.call(i)}:n&&n.set&&(f[t]=function(t,e){n.set.call(t,e)})},b=c[Symbol.iterator]();!(l=(m=b.next()).done);l=!0)d()}catch(t){g=!0,v=t}finally{try{l||null==b.return||b.return()}finally{if(g)throw v}}Object.assign(n[a(r)].getters,u),Object.assign(n[a(r)].mutations,f)}function o(t){void 0===n[a(t)]&&(n[a(t)]={namespaced:!0,state:function(){return{}},getters:{},actions:{},mutations:{}})}function a(t){var e=new t.constructor;return"function"==typeof e&&(e=new t),e.moduleName}function i(t,r,i){o(t),n[a(t)].actions[r]=function(n,o){for(var a=n.state,i={$store:{state:a,rootState:n.rootState,commit:n.commit,dispatch:n.dispatch,getters:n.getters,rootGetters:n.rootGetters}},s=Object.keys(a),c=0;c<s.length;c++){var u=s[c];Object.assign(i,e({},u,a[u]))}return t[r].call(i,o)}}function s(t){var r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=a(t);return r?e({},o,n[o]):n[o]}function c(t,r,i){o(t),n[a(t)].getters[r]=function(n,o,a,i){for(var s={$store:{state:n,getters:o,rootState:a,rootGetters:i}},c=Object.keys(n),u=0;u<c.length;u++){var f=c[u];Object.assign(s,e({},f,n[f]))}return t[r].call(s)}}function u(t,e,r){o(t),n[a(t)].getters[e]=function(t){return t[e]}}function f(e,r,i){o(e),n[a(e)].getters[r]=function(t){return t[r]},n[a(e)].mutations[r]=function(e,n){t.set(e,r,n)}}function l(t,e,r){o(t),n[a(t)].mutations[e]=function(n,r){t[e].call(n,r)}}function g(t){if("function"!=typeof t)return function(e){r(e);var o=n[a(e)];if(void 0!==t&&void 0!==t.extend){var i=!0,c=!1,u=void 0;try{for(var f,l=function(){var t=s(f.value),e=o.state(),n=t.state();o.state=function(){return Object.assign(e,n)},Object.assign(o.getters,t.getters),Object.assign(o.actions,t.actions),Object.assign(o.mutations,t.mutations)},g=t.extend[Symbol.iterator]();!(i=(f=g.next()).done);i=!0)l()}catch(t){c=!0,u=t}finally{try{i||null==g.return||g.return()}finally{if(c)throw u}}}void 0!==t&&(t.persistent?o.persistent=t.persistent:o.persistent=!1)};r(t)}export{i as Action,s as ExportVuexStore,c as Getter,u as HasGetter,f as HasGetterAndMutation,l as Mutation,g as VuexClass};
